// a method that takes the checkWinner method from KnotsAndCrosses and gives it different values based on if it is an ally or a opponent win 
         // then takes the depth that we have searched to and subtracts it from the maximum value
         // an ally win gives a positive value, a opponent win gives a negative value, and a tie gives 0
		   public static int checkWinnerConverted (KnotsAndCrosses kandc, String [][] board, String ally, String opponent, int depth){
		      int winScore = 0;
		      if (kandc.checkWinner("X", board)==true){
		         winScore = 10 + depth;
		      }else if (kandc.checkWinner("O", board)==true){
		         winScore = -10 - depth;
		      }
		      return winScore;
		   } 
		  // this is a method that uses the minimax algorithm to calculate the optimal value for the given board position
		   public static int AI (KnotsAndCrosses kandc,String [][] board,boolean maximizer, int depth, String ally, String opponent){
            // the termination function, checks for a win or a tie in either player 
		      int winnerValue = checkWinnerConverted(kandc, board, ally, opponent, depth);
            if (Math.abs(winnerValue) > 0 || depth==0 || !checkBoard(board)){
            return winnerValue;
            }  
		      int maxScore;
		      if (maximizer == true) { //checks if the player is a trying to find the maximum value
		         maxScore = Integer.MIN_VALUE;
		         for (int i = 0; i <=2; i++){ // search all the board positions to find moves left to be made
		            for (int j = 0; j <=2; j++){
		               if (board [i][j] == "why" ){// if it finds a move that has not been made, it makes a move in that square for the maximizing player
		                  board[i][j] = "X"; 
                        //calculates the maximum value of our default value which is set to the minimum value of an integer, and the return of AI
                        //it also lowers the depth 
		                  maxScore = Math.max(maxScore, AI(kandc, board, false, depth-1, ally, opponent)); 
		                  board[i][j] = "why"; // after we have found the value of the move, we undo it as to not have the cells be different from the board
		               }
		            }
		         }
		         return maxScore;
		      }else { // this does the same thing as the maximum player but instead tries to find the minimum value, still reduces the board by 1 
		         int minScore = Integer.MAX_VALUE;
		         for (int i = 0; i <=2; i++) {
		            for (int j = 0; j <=2; j++){
		               if (board [i][j]== "why"){
		                  board [i][j] = "O";
		                  minScore = Math.min(minScore, AI(kandc, board, true, depth-1, ally, opponent)); 
		                  board [i][j] = "why";                 
		               }
		            }
		         }      
		         return minScore;
		      }
		   }
		   // a method that uses AI to find the value of each move avalible
         // returns the coordinates of the said best move
		   public static int [] bestMove (KnotsAndCrosses kandc,String [][] board, int depth, String ally, String opponent) throws ArrayIndexOutOfBoundsException {
		      int [] bestMoveCoords= new int [2]; 
		      bestMoveCoords [0] = -1;
		      bestMoveCoords [1] = -1;
		      int highScore = -1000; // our initial highest value
		      for (int i = 0; i <=2; i++) {// searching all the board positions to find an empty one
		         for (int j = 0; j <=2; j++){
		            if (board [i][j]== "why"){// once it has found an empty one, it makes a move for ally player 
		               board [i][j] = "X";
		               int moveValueIndex = AI(kandc, board, false, depth, ally, opponent); // uses AI to find the value of that specific move
		               board[i][j] = "why"; // undoes the move 
		               if (moveValueIndex > highScore){ // if the value of the previous move is less than the value of the current move,
                     // we set the coordinates of that move to our array and the value of that move to our high score
		                  bestMoveCoords [0] = i;
		                  bestMoveCoords [1] = j;
		                  highScore = moveValueIndex;
		               }  
		               //System.out.println(highScore);
		            }
		         }
		      }
		      return bestMoveCoords;
		   }


