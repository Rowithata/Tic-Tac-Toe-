import java.awt.Color;
import java.awt.Font;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;
/*Connor Chang
 * notes to self:
 *DONT LET THE AI CHEAT
 */
 /* Indexing
 There are 9 squares in tic tac toe
 In our game they are represented in the front end with 9 jbuttons labled 1-9 
 In the back end they are represented by a 2D array with the 1st position being the x coordinate and the second being the y 
 The origin is placed at the top left corner of the grid of buttons 
 This means that the y values start at the top with 0 and end with 2 at the bottom 
 The cells start with 1 at the top left and read left to right then up to down 
 Example: cell 4 is the second from the top and furthest to the left, it is represented by the coordinates, (0, 1)
 */
public class Game 
{
	@SuppressWarnings("deprecation")
	public static void main (String[]args)throws ArrayIndexOutOfBoundsException 
	 {
      //Sends a message prompt to the player   
		JOptionPane.showMessageDialog(null, "Enjoy a life changing tic tac toe experience", 
		null, JOptionPane.INFORMATION_MESSAGE);
      //creates the jframe and sets up the background  
		JFrame f= new JFrame("Tic Tac Toe!");
		f.setSize(500,500);
		f.setVisible(true);
		f.setLayout(null);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setResizable(true);
		f.setLocationRelativeTo(null);
      f.setExtendedState(f.MAXIMIZED_BOTH);
		f.setCursor(0); 
		f.getContentPane().setBackground(new Color(130, 182, 217)); //sets the background to a pale dark blue 
		f.setDefaultLookAndFeelDecorated(true);
		
		int gamemode = message(f); //finds the game mode
      		
		String[][] board = new String [3][3]; //Declaring board, board is the back-end representation of the game
		ImageIcon img = new ImageIcon("C:\\Users\\rowit\\Downloads\\download.png");
		f.setIconImage(img.getImage());
		
	   KnotsAndCrosses kandc = new KnotsAndCrosses(); //creates a new object known as knots and crosses, a class used to check for wins
				
		JButton cell1= new JButton(""); //Creating the grid through a series of buttons
		JButton cell2= new JButton(""); 
		JButton cell3= new JButton("");
		JButton cell4= new JButton("");
		JButton cell5= new JButton("");
		JButton cell6= new JButton("");
		JButton cell7= new JButton("");
		JButton cell8= new JButton("");
		JButton cell9= new JButton("");
		//Creating the other buttons and text that goes on the screen 
		JButton Reset= new JButton("");
		JButton help= new JButton("Help");
		JLabel Turn = new JLabel("Take your time, O");
		JLabel Win = new JLabel("");
      JLabel Wins = new JLabel("");
      
      int depth = 6; // the varible that tracks how far we recurse in the method AI, used for move optimization 
      
		boolean isX = true; // this is the variable that declares wheather the bot is playing as x or o 
      String ally = " ";
      String opponent = " ";
      
      Random rand = new Random();
      cell1.setBackground(new Color (76, 187, 23));//setting the color of the buttons in an alternating pattern of green and yellow, this one is green
      cell2.setBackground(new Color (255, 233, 55));//this one is yellow....
      cell3.setBackground(new Color (76, 187, 23));//green...
      cell4.setBackground(new Color (255, 233, 55));
      cell5.setBackground(new Color (76, 187, 23));
      cell6.setBackground(new Color (255, 233, 55));
      cell7.setBackground(new Color (76, 187, 23));
      cell8.setBackground(new Color (255, 233, 55));
      cell9.setBackground(new Color (76, 187, 23));
      Reset.setBackground(new Color (76, 187, 23)); 
      help.setBackground(new Color (255, 233, 55));     
      //https://www.webfx.com/web-design/hex-to-rgb/
      //hex to rgb finder plus color finder 
		clearboard(board,cell1,cell2,cell3,cell4,cell5,cell6,cell7,cell8,cell9); // sets the cells to a default state
		 help.addActionListener(new ActionListener() 
		 {
		      @Override
		      public void actionPerformed(ActionEvent e) 
		      {
		  		Object[] options = 
		  			{
		  				"Change Gamemode",
		  				"Nevermind lol",
		  				"Close Game"
		  	        };
		  			int n = JOptionPane.showOptionDialog(f,
		  					"Ya?",
		  					"Whatdya want",
		  					JOptionPane.YES_NO_CANCEL_OPTION,
		  					JOptionPane.QUESTION_MESSAGE,
		  					null,
		  				options,
		  				options[2]);
		  			if(n == JOptionPane.CANCEL_OPTION)
		  			{
		  				f.dispatchEvent(new WindowEvent(f, WindowEvent.WINDOW_CLOSING));
		  			}
		  			else if(n == JOptionPane.YES_OPTION) 
		  			{
		  				clearboard(board,cell1,cell2,cell3,cell4,cell5,cell6,cell7,cell8,cell9);
		  			    message(f);
		  			}
		  			else if(n == JOptionPane.NO_OPTION) 
		  			{
		  			}
		      }
		  });
		
		f.add(cell1); //Adding all needed buttons and text to JFrame
		f.add(cell2);
		f.add(cell3);
		f.add(cell4);
		f.add(cell5);
		f.add(cell6);
		f.add(cell7);
		f.add(cell8);
		f.add(cell9);
      
		f.add(Reset); //Adds all non board buttons and labels.	
		f.add(Turn);
		f.add(Win);
		f.add(Wins);
		f.add(help);
      System.out.println(f.getWidth());
      System.out.println(f.getHeight());
		//Finds the position of the Jframe in pixels
      //calculates the placement and size of the buttons and text as percenteges of the total pixels of the screen in the x and y direction
      //This allows the buttons to be automaticaly scaled to whatever screen the JFrame is maximized to  
      /*int boxDimensions = (int)(f.getHeight()*0.30);
      int xVal = (int)((f.getWidth()/2)-(boxDimensions*1.5));
      int yVal = (int)(f.getHeight()*0.025);
      int resetXSize = boxDimensions;
      int resetYSize = boxDimensions/4;
 		cell1.setBounds(xVal,yVal,boxDimensions, boxDimensions);
		cell2.setBounds(xVal+boxDimensions,yVal,boxDimensions, boxDimensions);
		cell3.setBounds(xVal+(boxDimensions*2),yVal,boxDimensions, boxDimensions);
		cell4.setBounds(xVal,yVal+boxDimensions,boxDimensions, boxDimensions);
		cell5.setBounds(xVal+boxDimensions,yVal+boxDimensions, boxDimensions, boxDimensions);
		cell6.setBounds(xVal+(boxDimensions*2),yVal+boxDimensions,boxDimensions, boxDimensions);
		cell7.setBounds(xVal,yVal+(boxDimensions*2),boxDimensions, boxDimensions);
		cell8.setBounds(xVal+boxDimensions,yVal+(boxDimensions*2),boxDimensions, boxDimensions);
		cell9.setBounds(xVal+(boxDimensions*2),yVal+(boxDimensions*2),boxDimensions, boxDimensions);
		Reset.setBounds((xVal/2)-(resetXSize/2),(f.getHeight()/2)-resetYSize,resetXSize,resetYSize);
      Turn.setBounds((xVal/2)-(resetXSize/2),(f.getHeight()/2)+resetYSize,resetXSize*2, resetYSize);
	   Win.setBounds((xVal/2)-(resetXSize/2),(f.getHeight()/3),resetXSize,resetYSize);
	   Wins.setBounds((xVal/2)-(resetXSize/2),((f.getHeight()/2)-resetYSize)+(int)(resetYSize*1.25),resetXSize,resetYSize);*/
      rescale(cell1, cell2, cell3, cell4, cell5, cell6, cell7, cell8, cell9, f, Reset, Turn, Win, Wins);
		//help.setBounds(0,0,(int)(f.getWidth()*.13),(int)(f.getHeight()*.07));
		Reset.setText("Reset Board");
      int [] begin = startingPositions (rand);
      for (int i=0; i <= 1; i++){
         System.out.print(begin[i]);
      
      }
      /*f.addWindowListener(new WindowListener()
      {
         @Override 
         public void windowIconified(WindowEvent e){
         
         
         }
         });*/
      /*f.addActionListener(new ActionListener()
      {
         @Override 
         public void actionPerformed(ActionEvent f){
         
         
         }
         
         });*/
	    Reset.addActionListener(new ActionListener() //Whenever the reset button is pressed the cells get cleared of all text and the board gets changed to having nothing in it  
	    {
	        @Override
	        public void actionPerformed(ActionEvent e) 
	        {
	        	clearboard(board,cell1,cell2,cell3,cell4,cell5,cell6,cell7,cell8,cell9);
	        	Win.setText("");
	        }
	    });
	   		
		ActionListener e = (ActionListener) new ActionListener()//oh lord,
      //whenever the action listener detects a button has been pressed, it send calls a method to change the text of the cell and the text in the board 
      //to be that of the corrusponding player depending on whoevers turn it is
		{
			int player=1; 
			boolean error;
			int XWins = 0;
			int YWins = 0; 
			public void actionPerformed(ActionEvent e) 
			{
				Object obj = e.getSource();
				if(obj==cell1) //0,0
				{
					error = move(cell1,player,board,0,0,gamemode);
				}
				else if (obj==cell2) //1,0
				{
					error = move(cell2,player,board,1,0,gamemode);
				}
		    	else if (obj==cell3) //2,0
		    	{
		    		error = move(cell3,player,board,2,0,gamemode);
		    	}
		    	else if (obj==cell4) //0,1
		    	{
		    		error = move(cell4,player,board,0,1,gamemode);
		    	}
		    	else if (obj==cell5) //1,1
		    	{
		    		error = move(cell5,player,board,1,1,gamemode);
		    	}
		    	else if (obj==cell6) //2,1
		    	{
		    		error = move(cell6,player,board,2,1,gamemode);
		    	}
		    	else if (obj==cell7) //0,2
		    	{
		    		error = move(cell7,player,board,0,2,gamemode);
		    	}
		    	else if (obj==cell8) //1,2
		    	{
		    		error = move(cell8,player,board,1,2,gamemode);
		    	}
		    	else if (obj==cell9) //2,2
		    	{
		    		error = move(cell9,player,board,2,2,gamemode);
		    	}
				//Below are constants, that happen every time
				//somebody makes a move.
				if (error!=true)
				{
					if (gamemode == 2) //For AI Mode
					{
						if (player%2 == 1)
						{
							int x [] = bestMove(kandc, board, depth, ally, opponent, isX); //changed player to moves
							x.toString();
							for (int i = 0; i <x.length; i++) //Prints out best move.
							{
								System.out.print(x[i]);
							}
	                     	AIMove(kandc, board, cell1, cell2, cell3, cell4, cell5, 
	       	                cell6, cell7, cell8, cell9,x, ally, opponent, isX);
	                     	 player++;
						}
					}
					
					if (kandc.checkWinner("X",board)==true)
					{
						Win.setText("wow bravo X");
						Turn.setText("");
						XWins++;
						disableBoard(cell1, cell2, cell3, cell4, cell5, 
			       	    cell6, cell7, cell8, cell9);
						player=0;
					}
					else if (kandc.checkWinner("O",board)==true)
				    {
						Win.setText("I KNEW YOU COULD DO IT, O");
						Turn.setText("");
						YWins++;
						disableBoard(cell1, cell2, cell3, cell4, cell5, 
		       	        cell6, cell7, cell8, cell9);
						player=0;
					} 
					
				  	 player++;
	                 if (cell1.isEnabled()){player=checkplayer(Turn,player);}
	                 Wins.setText("X:"+XWins+" Wins. O:"+YWins+" Wins.");
	               //1101111011
	            }
				else {error=false;}
				}
		};
		
		cell1.addActionListener((ActionListener) e);//Adds action listener to all buttons 
		cell2.addActionListener((ActionListener) e);
		cell3.addActionListener((ActionListener) e);
		cell4.addActionListener((ActionListener) e);
		cell5.addActionListener((ActionListener) e);
		cell6.addActionListener((ActionListener) e);
		cell7.addActionListener((ActionListener) e);
		cell8.addActionListener((ActionListener) e);
		cell9.addActionListener((ActionListener) e);
		
	}
	
	public static void error ()
	{
		 JPanel panel = new JPanel();
		 JOptionPane.showMessageDialog(panel, "This spot is already taken!",
		 "Woah Buddy", JOptionPane.ERROR_MESSAGE);
	}
	
	public static String[][] clearboard(String[][] board,JButton cell1, JButton cell2, 
			JButton cell3, JButton cell4, JButton cell5, JButton cell6, JButton cell7, 
			JButton cell8, JButton cell9)
	{
		for (int i=0;i<=2;i++) //Changing all values to "Why"
		{
			for (int j=0;j <=2;j++)
			{
			board[j][i]="why";
			}
		}
    	cell1.setText("");
    	cell2.setText("");
    	cell3.setText("");
    	cell4.setText("");
    	cell5.setText("");
    	cell6.setText("");
    	cell7.setText("");
    	cell8.setText("");
    	cell9.setText("");
    	
		cell1.setEnabled(true);
		cell2.setEnabled(true);
		cell3.setEnabled(true);
		cell4.setEnabled(true);
		cell5.setEnabled(true);
		cell6.setEnabled(true);
		cell7.setEnabled(true);
		cell8.setEnabled(true);
		cell9.setEnabled(true);
		return board;
	}
   public static void rescale (JButton cell1,
		   JButton cell2, JButton cell3, JButton cell4, JButton cell5, 
		   JButton cell6, JButton cell7, JButton cell8, JButton cell9,
         JFrame f, JButton Reset, JLabel Turn, JLabel Win, JLabel Wins){
   int boxDimensions = (int)(f.getHeight()*0.30);
      int xVal = (int)((f.getWidth()/2)-(boxDimensions*1.5));
      int yVal = (int)(f.getHeight()*0.025);
      int resetXSize = boxDimensions;
      int resetYSize = boxDimensions/4;
 		cell1.setBounds(xVal,yVal,boxDimensions, boxDimensions);
		cell2.setBounds(xVal+boxDimensions,yVal,boxDimensions, boxDimensions);
		cell3.setBounds(xVal+(boxDimensions*2),yVal,boxDimensions, boxDimensions);
		cell4.setBounds(xVal,yVal+boxDimensions,boxDimensions, boxDimensions);
		cell5.setBounds(xVal+boxDimensions,yVal+boxDimensions, boxDimensions, boxDimensions);
		cell6.setBounds(xVal+(boxDimensions*2),yVal+boxDimensions,boxDimensions, boxDimensions);
		cell7.setBounds(xVal,yVal+(boxDimensions*2),boxDimensions, boxDimensions);
		cell8.setBounds(xVal+boxDimensions,yVal+(boxDimensions*2),boxDimensions, boxDimensions);
		cell9.setBounds(xVal+(boxDimensions*2),yVal+(boxDimensions*2),boxDimensions, boxDimensions);
		Reset.setBounds((xVal/2)-(resetXSize/2),(f.getHeight()/2)-resetYSize,resetXSize,resetYSize);
      Turn.setBounds((xVal/2)-(resetXSize/2),(f.getHeight()/2)+resetYSize,resetXSize*2, resetYSize);
	   Win.setBounds((xVal/2)-(resetXSize/2),(f.getHeight()/3),resetXSize,resetYSize);
	   Wins.setBounds((xVal/2)-(resetXSize/2),((f.getHeight()/2)-resetYSize)+(int)(resetYSize*1.25),resetXSize,resetYSize);
      
      
      Font font = new Font("Comic Sans MS", Font.BOLD,xVal/3);
		Font smallFont = new Font("Comic Sans MS", Font.PLAIN,resetYSize/3);
		cell1.setFont(font);//Adds cell font to the buttons
		cell2.setFont(font);
		cell3.setFont(font);
		cell4.setFont(font);
		cell5.setFont(font);
		cell6.setFont(font);
		cell7.setFont(font);
		cell8.setFont(font);
		cell9.setFont(font);
		
		Turn.setFont(smallFont); //adds font to all the text
		Win.setFont(smallFont);
		Wins.setFont(smallFont);
		Reset.setFont(smallFont);
   
   }
	
	public static int checkplayer(JLabel Turn,int player) //tracks which whose turn it is and gives a message accordingly
	{
     	 if (player%2==0)
		{
			Turn.setText("Hurry up X, make your move");
		}
		else
		{
			Turn.setText("Take your time, O");
		}
		return player;
	}
	
	public static int message (JFrame f)// here is said message
	{
		Object[] options = 
		{
			"1v1",
			"Fite me bot",
			"take me back"
        };
		int n = JOptionPane.showOptionDialog(f,
				"How do you want to play?",
				"Welcome",
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.QUESTION_MESSAGE,
				null,
			options,
			options[2]);
		if(n == JOptionPane.CANCEL_OPTION)//take me back
		{
			f.dispatchEvent(new WindowEvent(f, WindowEvent.WINDOW_CLOSING));
		}
		else if(n == JOptionPane.YES_OPTION) //1v1
		{
			//Starts a 1v1 gamemode
			return 1;
		}
		else if(n == JOptionPane.NO_OPTION) //fite me bot
		{
			return 2;
		}
		else if (n== JOptionPane.CLOSED_OPTION)
		{
			message(f);
		}
		return 0;
	}   
   public static int [] startingPositions  (Random rand){
      int [] startCoords = new int [2];
      startCoords [0] = -1;
      startCoords [1] = -1;
      int starter = rand.nextInt(4); 
      if (starter == 0){
         startCoords [0] = 0;
         startCoords [1] = 0; 
      }else if (starter == 1){
         startCoords [0] = 0;
         startCoords [1] = 2;
      }else if (starter == 2){
         startCoords [0] = 2;
         startCoords [1] = 0;
      }else if (starter == 3){
         startCoords [0] = 2;
         startCoords [1] = 2;
      }else if (starter == 4){
         startCoords [0] = 1;
         startCoords [1] = 1;
      }
      return startCoords;
   }
		   // a method that takes the checkWinner method from KnotsAndCrosses and gives it different values based on if it is an ally or a opponent win 
         // then takes the depth that we have searched to and subtracts it from the maximum value
         // an ally win gives a positive value, a opponent win gives a negative value, and a tie gives 0
		   public static int checkWinnerConverted (KnotsAndCrosses kandc, String [][] board, String ally, String opponent, int depth, boolean isX){
            if (isX = true){
               ally = "X";
               opponent = "O";
            }else if(isX = false){
               ally = "O";
               opponent = "X";
            }
		      int winScore = 0;
		      if (kandc.checkWinner(ally , board)==true){
		         winScore = 10 + depth;
		      }else if (kandc.checkWinner(opponent, board)==true){
		         winScore = -10 - depth;
		      }
		      return winScore;
		   } 
		  // this is a method that uses the minimax algorithm to calculate the optimal value for the given board position
		   public static int AI (KnotsAndCrosses kandc,String [][] board,boolean maximizer, int depth, String ally, String opponent, boolean isX){
            if (isX = true){
               ally = "X";
               opponent = "O";
            }else if(isX = false){
               ally = "O";
               opponent = "X";
            }
            //The function will terminate if either, the winnerValue is positive, indicating a win for ally
            //If the depth has reached its max, primarily used as a saftey net 
            //Or if there are no positions left on the board
		      int winnerValue = checkWinnerConverted(kandc, board, ally, opponent, depth, isX);
            if (Math.abs(winnerValue) > 0 || depth==0 || !checkBoard(board)){
            return winnerValue;
            }  
		      int maxScore;
		      if (maximizer == true) { //checks if the player is a trying to find the maximum value
		         maxScore = Integer.MIN_VALUE;
		         for (int i = 0; i <=2; i++){ // search all the board positions to find moves left to be made
		            for (int j = 0; j <=2; j++){
		               if (board [i][j] == "why" ){// if it finds a move that has not been made, it makes a move in that square for the maximizing player
		                  board[i][j] = ally; 
                        //calculates the maximum value of our default value which is set to the minimum value of an integer, and the return of AI
                        //it also lowers the depth 
		                  maxScore = Math.max(maxScore, AI(kandc, board, false, depth-1, ally, opponent, isX)); 
		                  board[i][j] = "why"; // after we have found the value of the move, we undo it as to not have the cells be different from the board
		               }
		            }
		         }
		         return maxScore;
		      }else { // this does the same thing as the maximum player but instead tries to find the minimum value, still reduces the board by 1 
		         int minScore = Integer.MAX_VALUE;
		         for (int i = 0; i <=2; i++) {
		            for (int j = 0; j <=2; j++){
		               if (board [i][j]== "why"){
		                  board [i][j] = opponent;
		                  minScore = Math.min(minScore, AI(kandc, board, true, depth-1, ally, opponent, isX)); 
		                  board [i][j] = "why";                 
		               }
		            }
		         }      
		         return minScore;
		      }
		   }
		   // a method that uses AI to find the value of each move avalible
         // returns the coordinates of the said best move
		   public static int [] bestMove (KnotsAndCrosses kandc,String [][] board, int depth, String ally, String opponent, boolean isX) throws ArrayIndexOutOfBoundsException {
		      if (isX = true){
               ally = "X";
               opponent = "O";
            }else if(isX = false){
               ally = "O";
               opponent = "X";
            }
            int [] bestMoveCoords= new int [2]; 
		      bestMoveCoords [0] = -1;
		      bestMoveCoords [1] = -1;
		      int highScore = -1000; // our initial highest value
		      for (int i = 0; i <=2; i++) {// searching all the board positions to find an empty one
		         for (int j = 0; j <=2; j++){
		            if (board [i][j]== "why"){// once it has found an empty one, it makes a move for ally player 
		               board [i][j] = ally;
		               int moveValueIndex = AI(kandc, board, false, depth, ally, opponent, isX); // uses AI to find the value of that specific move
		               board[i][j] = "why"; // undoes the move 
		               if (moveValueIndex > highScore){ // if the value of the previous move is less than the value of the current move,
                     // we set the coordinates of that move to our array and the value of that move to our high score
		                  bestMoveCoords [0] = i;
		                  bestMoveCoords [1] = j;
		                  highScore = moveValueIndex;
		               }  
		               //System.out.println(highScore);
		            }
		         }
		      }
		      return bestMoveCoords;
		   }
		   // once a game has been won this method is called and all the cells can not be clicked
		   public static void disableBoard (JButton cell1,
		   JButton cell2, JButton cell3, JButton cell4, JButton cell5, 
		   JButton cell6, JButton cell7, JButton cell8, JButton cell9)
		   {
				cell1.setEnabled(false);
				cell2.setEnabled(false);
				cell3.setEnabled(false);
				cell4.setEnabled(false);
				cell5.setEnabled(false);
				cell6.setEnabled(false);
				cell7.setEnabled(false);
				cell8.setEnabled(false);
				cell9.setEnabled(false);
		   }
		   // takes the coordinates determained by bestMove for the current board postision and changes the corresponding cell for ally
		   public static void AIMove ( KnotsAndCrosses kandc,String [][] board,JButton cell1,
		   JButton cell2, JButton cell3, JButton cell4, JButton cell5, 
		   JButton cell6, JButton cell7, JButton cell8, JButton cell9,int[] x, String ally, String opponent, boolean isX) 
		   {
           if (isX = true){
            ally = "X";
            opponent = "O";
           }else if(isX = false){
            ally = "O";
            opponent = "X";
           }
			   try 
			   {
				   int X=x[0];
				   int Y=x[1];		
				   //System.out.print(X+""+Y);
				   if(X==0&&Y==0) //Cell1
				   {
					   cell1.setText(ally);
				   }
				   else if(X==1&&Y==0) //Cell2
				   {
					   cell2.setText(ally);
				   }
				   else if(X==2&&Y==0) //Cell3
				   {
					   cell3.setText(ally);
				   }
				   else if(X==0&&Y==1) //Cell4
				   {
					   cell4.setText(ally);
				   }
				   else if(X==1&&Y==1) //Cell5
				   {
					   cell5.setText(ally);
				   }
				   else if(X==2&&Y==1) //Cell6
				   {
					   cell6.setText(ally);
				   }
				   else if(X==0&&Y==2) //Cell7
				   {
					   cell7.setText(ally);
				   }
				   else if(X==1&&Y==2) //Cell8
				   {
					   cell8.setText(ally);
				   }
				   else if(X==2&&Y==2) //Cell9
				   {
					   cell9.setText(ally);
				   }
			   board[X][Y]=ally;
			   }
			   catch (Exception e)
			   {// if there is a tie this message pannel pops up 
					 JPanel panel = new JPanel();
					 JOptionPane.showMessageDialog(panel, "Tie Lmao you both dog water",
					 "Lol", JOptionPane.ERROR_MESSAGE);
					 clearboard(board,cell1,cell2,cell3,cell4,cell5,
							    cell6,cell7,cell8,cell9);
					 
			   }
		   }
		   //happens every time a player makes a move 
		   public static boolean move(JButton cell,int turn,String[][] board,int x, int y,int gamemode)
		   {
			   if (board[x][y] == "why")
			   {
				   if (turn%2==0 && gamemode!=2)//X
				   {
					   cell.setText("X");
					   board[x][y]="X";
					   return false;
				   }
				   else//X
				   {
					   cell.setText("O");
					   board[x][y]="O";
					   return false;
				   }
			   }
			   else{error(); return true;}
		   }
		   // checks if there are any moves left on the board to be made
		   public static boolean checkBoard(String[][] board)
		   {
			   for (int i=0; i<=2; i++)
			   {
				   for (int j=0; j<=2; j++)
				   {
					   if (board[i][j]=="why")
					   {
						   return true;
					   }
				   }
			   }
			   return false;
		   }
}
